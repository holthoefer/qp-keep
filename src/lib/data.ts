
'use client';

import { db } from './firebase';
import {
  collection,
  query,
  where,
  onSnapshot,
  addDoc,
  serverTimestamp,
  doc,
  deleteDoc,
  updateDoc,
  getDocs,
  getDoc,
  setDoc,
  Timestamp,
  orderBy,
} from 'firebase/firestore';
import { suggestTags } from '@/ai/flows/suggest-tags';

export interface Note {
  id: string;
  userId: string;
  userEmail?: string; // Add optional userEmail for admin view
  title: string;
  content: string;
  tags?: string[];
  createdAt: Timestamp;
}

export interface UserProfile {
    uid: string;
    email: string;
    role: 'admin' | 'user';
    status: 'active' | 'inactive';
    createdAt?: Timestamp;
}

export interface ControlPlanItem {
    id: string;
    task: string;
    responsible: string;
    status: 'pending' | 'in_progress' | 'completed';
    createdAt: Timestamp;
}


// Note: Omit `id` and `createdAt` because they are generated by Firestore.
export const addNote = async (note: Omit<Note, 'id' | 'createdAt' | 'userEmail'> & { userEmail: string }) => {
    // First, check if the user is active before attempting to add a note.
    const userProfile = await getProfile(note.userId);
    if (userProfile?.status !== 'active') {
        throw new Error('Ihr Konto ist inaktiv. Sie kÃ¶nnen keine neuen Notizen erstellen.');
    }

    try {
        const { tags } = await suggestTags({ noteContent: `${note.title}\n${note.content}` });
        await addDoc(collection(db, 'notes'), {
            ...note,
            tags: tags || [],
            createdAt: serverTimestamp(),
        });
    } catch (error) {
        console.error("Error adding note with tags:", error);
        // Fallback to adding note without tags if AI fails
        await addDoc(collection(db, 'notes'), {
            ...note,
            tags: [],
            createdAt: serverTimestamp(),
        });
    }
};

export const getNotes = (
  userId: string,
  isAdmin: boolean,
  onSuccess: (notes: Note[]) => void,
  onError: (error: Error) => void,
) => {
  let q;
  if (isAdmin) {
    // Admin query: Get all notes
    q = query(collection(db, 'notes'), orderBy('createdAt', 'desc'));
  } else {
    // Regular user query: Get only their notes
    q = query(collection(db, 'notes'), where('userId', '==', userId), orderBy('createdAt', 'desc'));
  }
  
  const unsubscribe = onSnapshot(q, 
    (querySnapshot) => {
      const notes: Note[] = [];
      querySnapshot.forEach((doc) => {
        notes.push({ id: doc.id, ...doc.data() } as Note);
      });
      onSuccess(notes);
    }, 
    (error) => {
      console.error("Firestore getNotes error: ", error);
      onError(error);
    }
  );
  
  return unsubscribe;
};

export const deleteNote = async (noteId: string) => {
    const noteRef = doc(db, 'notes', noteId);
    await deleteDoc(noteRef);
}

// --- User Management Functions ---

export const createUserProfile = async (userProfile: Omit<UserProfile, 'createdAt'>) => {
    const userDocRef = doc(db, 'users', userProfile.uid);
    await setDoc(userDocRef, {
        ...userProfile,
        createdAt: serverTimestamp(),
    });
};

export const getProfile = async (userId: string): Promise<UserProfile | null> => {
    const userDocRef = doc(db, 'users', userId);
    try {
        const userDocSnap = await getDoc(userDocRef);
        if (userDocSnap.exists()) {
            // Combine uid with document data
            return { uid: userDocSnap.id, ...userDocSnap.data() } as UserProfile;
        }
        return null;
    } catch (error) {
        console.error("Error fetching profile for", userId, error);
        // Depending on Firestore rules, this might throw if a user tries to fetch another's profile.
        // Returning null is a safe default.
        return null;
    }
}

export const getAllUsers = async (): Promise<UserProfile[]> => {
    const usersCollectionRef = collection(db, 'users');
    const q = query(usersCollectionRef);
    const querySnapshot = await getDocs(q);
    const users: UserProfile[] = [];
    querySnapshot.forEach((doc) => {
        users.push({ uid: doc.id, ...doc.data() } as UserProfile);
    });
    return users;
};

export const updateUser = async (userId: string, data: Partial<UserProfile>) => {
    const userDocRef = doc(db, 'users', userId);
    await updateDoc(userDocRef, data);
};

// --- Control Plan Functions ---

export const getControlPlanItems = (
    onSuccess: (items: ControlPlanItem[]) => void,
    onError: (error: Error) => void
) => {
    const q = query(collection(db, 'controlplan'), orderBy('createdAt', 'desc'));
    const unsubscribe = onSnapshot(q,
        (querySnapshot) => {
            const items: ControlPlanItem[] = [];
            querySnapshot.forEach((doc) => {
                items.push({ id: doc.id, ...doc.data() } as ControlPlanItem);
            });
            onSuccess(items);
        },
        (error) => {
            console.error("Firestore getControlPlanItems error:", error);
            onError(error);
        }
    );
    return unsubscribe;
};

export const addControlPlanItem = async (item: Omit<ControlPlanItem, 'id' | 'createdAt'>) => {
    await addDoc(collection(db, 'controlplan'), {
        ...item,
        createdAt: serverTimestamp(),
    });
};

export const updateControlPlanItem = async (id: string, data: Partial<Omit<ControlPlanItem, 'id' | 'createdAt'>>) => {
    const itemRef = doc(db, 'controlplan', id);
    await updateDoc(itemRef, data);
};

export const deleteControlPlanItem = async (id: string) => {
    const itemRef = doc(db, 'controlplan', id);
    await deleteDoc(itemRef);
};
