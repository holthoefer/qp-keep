
'use client';

import { db } from './firebase';
import {
  collection,
  query,
  where,
  onSnapshot,
  addDoc,
  serverTimestamp,
  doc,
  deleteDoc,
  updateDoc,
  getDocs,
  getDoc,
  Timestamp
} from 'firebase/firestore';
import { suggestTags } from '@/ai/flows/suggest-tags';

export interface Note {
  id: string;
  userId: string;
  title: string;
  content: string;
  tags?: string[];
  createdAt: Timestamp;
}

export interface UserProfile {
    uid: string;
    email: string;
    role: 'admin' | 'user';
    status: 'active' | 'inactive';
    createdAt: Timestamp;
}


// Note: Omit `id` and `createdAt` because they are generated by Firestore.
export const addNote = async (note: Omit<Note, 'id' | 'createdAt'>) => {
    try {
        const { tags } = await suggestTags({ noteContent: `${note.title}\n${note.content}` });
        await addDoc(collection(db, 'notes'), {
            ...note,
            tags: tags || [],
            createdAt: serverTimestamp(),
        });
    } catch (error) {
        console.error("Error adding note with tags:", error);
        // Fallback to adding note without tags if AI fails
        await addDoc(collection(db, 'notes'), {
            ...note,
            tags: [],
            createdAt: serverTimestamp(),
        });
    }
};

export const getNotes = (
  userId: string,
  onSuccess: (notes: Note[]) => void,
  onError: (error: Error) => void,
) => {
  // Query without server-side ordering to avoid needing an index immediately.
  const q = query(
    collection(db, 'notes'), 
    where('userId', '==', userId)
  );
  
  const unsubscribe = onSnapshot(q, 
    (querySnapshot) => {
      const notes: Note[] = [];
      querySnapshot.forEach((doc) => {
        notes.push({ id: doc.id, ...doc.data() } as Note);
      });
      // Sort notes on the client-side by creation date (newest first)
      notes.sort((a, b) => {
        const dateA = a.createdAt?.toDate() ?? new Date(0);
        const dateB = b.createdAt?.toDate() ?? new Date(0);
        return dateB.getTime() - dateA.getTime();
      });

      onSuccess(notes);
    }, 
    (error) => {
      console.error("Firestore getNotes error: ", error);
      onError(error);
    }
  );
  
  return unsubscribe;
};

export const deleteNote = async (noteId: string) => {
    const noteRef = doc(db, 'notes', noteId);
    await deleteDoc(noteRef);
}

// --- User Management Functions ---

export const getProfile = async (userId: string): Promise<UserProfile | null> => {
    const userDocRef = doc(db, 'users', userId);
    const userDocSnap = await getDoc(userDocRef);
    if (userDocSnap.exists()) {
        return userDocSnap.data() as UserProfile;
    }
    return null;
}

export const getAllUsers = async (): Promise<UserProfile[]> => {
    const usersCollectionRef = collection(db, 'users');
    const q = query(usersCollectionRef);
    const querySnapshot = await getDocs(q);
    const users: UserProfile[] = [];
    querySnapshot.forEach((doc) => {
        users.push({ uid: doc.id, ...doc.data() } as UserProfile);
    });
    return users;
};

export const updateUser = async (userId: string, data: Partial<UserProfile>) => {
    const userDocRef = doc(db, 'users', userId);
    await updateDoc(userDocRef, data);
};
